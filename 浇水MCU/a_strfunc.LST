C51 COMPILER V9.00   A_STRFUNC                                                             12/15/2017 18:39:34 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE A_STRFUNC
OBJECT MODULE PLACED IN a_strfunc.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE a_strfunc.c LARGE BROWSE DEBUG OBJECTEXTEND

line level    source

   1          
   2           //     2017-01-12
   3          
   4          //#include "reg52.h"
   5          #include "STDIO.H"
   6          #include "STDLIB.H"
   7          #include "INTRINS.H"
   8          #include "STRING.H"
   9          #include "a_strfunc.h"
  10          
  11          
  12          
  13          
  14          /*------------------------------------------------
  15          数字变字串。最多只能处理9个有效数
  16          例如
  17          NumNum 0x72 所有数字个数7，不足补前0。小数部分有2
  18          例如值=4，    配置0x03，输出0.004
  19          例如值=12345，配置0x01, 输出1234.5
  20          ------------------------------------------------*/
  21          #if 0
              void myltoa( unsigned char * szOut, unsigned long i, unsigned char NumNum )  
              {
                      unsigned char c = 0;
                      unsigned char flag = 0;
                      unsigned char wei;
                      unsigned long a10 = 1;
              
                      if( i == 0 )
                              *(szOut++) = '0';
                      
                      for( wei = 9 ; wei > 0; wei -- )
                      {
                              a10 = 1;
                              for( c = 0; c < wei-1; c++ ) a10 *= 10;
                              c = (i/a10) % 10;
              
                              if( wei == ( NumNum & 0x0F ) )
                              {
                                      if( flag == 0 )  *(szOut++) = '0';
                                      flag = 1;
                                      *(szOut++) = '.';
                              }
              
                              if( flag || c == 0 && ( NumNum >> 4 ) >= wei || c !=0 ) 
                              {
                                      flag = 1;
                                      *(szOut++) = c + '0';
                              }
                      }
              
                      *szOut = 0;
              }
              #endif
  55          
C51 COMPILER V9.00   A_STRFUNC                                                             12/15/2017 18:39:34 PAGE 2   

  56          
  57          
  58          
  59          
  60          
  61          
  62          /*------------------------------------------------
  63          任务间传递数据
  64          // [0] 是.m_is_busy 
  65          // [1]是.m_is_hot 
  66          ------------------------------------------------*/
  67          #if 0
              
              void sharedata_interrupt_ready( U8 *tWork, U8 *t0, U8 *t1, int len )
              {
                      tWork[0] = 0;   // [0] 是.m_is_busy = 0;
                      tWork[1] = 1;   // [1] 是.m_is_hot = 1;
              
                      if( !(t0[0]) ) memcpy( t0, tWork, len ) ;
                      if( !(t1[0]) ) memcpy( t1, tWork, len ) ;
              }
              
              void sharedata_main_followrefresh( U8 *t0, U8 *t1, U8 *t2, int len ) 
              {
                      t0[0] = 1;      
                      if( t0[1] ) memcpy( t2, t0, len ) ;
                      t0[1] = 0;      
                      t0[0] = 0;      
                       
                      t1[0] = 1;      
                      if( t1[1] ) memcpy( t2, t1, len ) ;
                      t1[1] = 0;      
                      t1[0] = 0;               
              }
              
              #endif
  92          
  93          
  94          
  95          
  96          
  97          
  98          /*------------------------------------------------
  99          数据头上删除一部分。大搬家
 100          ------------------------------------------------*/
 101          #if 0
              U16 buf_del_head( U8 *p, U16 qlen, U16 headlen )
              {
                      U16 iread = headlen;
                      U16 iwrite = 0;
                      
                      for( ; iread < qlen; iread++ )
                      {
                              p[iwrite] = p[iread];
                              iwrite++;
                      }
                      return iwrite;
              }
              #endif
 115          
 116          
 117          
C51 COMPILER V9.00   A_STRFUNC                                                             12/15/2017 18:39:34 PAGE 3   

 118          
 119          
 120          /*------------------------------------------------
 121          例如 0xaa , 输出返回2字节 "AA"
 122          ------------------------------------------------*/
 123          #if 0
              void bs_9_A( unsigned char c, unsigned char *p_dest ) 
              {
                      unsigned char i;
              
                      i = c;
                      i >>= 4;
                      if( i >= 0 && i <= 9 ) p_dest[0] = '0' + i; else p_dest[0] = 'A' + ( i - 10 );
                              
                      i = c & 0x0F;
                      if( i >= 0 && i <= 9 ) p_dest[1] = '0' + i; else p_dest[1] = 'A' + ( i - 10 );
              }
              #endif
 136          
 137          
 138          
 139          
 140          /*------------------------------------------------
 141          例如 "AA" , 一次处理2字节，输出返回1字节 0xAA
 142          ------------------------------------------------*/
 143          #if 0
              unsigned char bs_A_9( unsigned char *p_src )
              {
                      unsigned char _tempbuf[2];
              
                      _tempbuf[0] = p_src[0];
                      if( _tempbuf[0] >= '0' && _tempbuf[0] <= '9' ) _tempbuf[0] -= '0'; else _tempbuf[0] -= 'A' - 10;
                              
                      _tempbuf[1] = p_src[1];
                      if( _tempbuf[1] >= '0' && _tempbuf[1] <= '9' ) _tempbuf[1] -= '0'; else _tempbuf[1] -= 'A' - 10;
              
                      return _tempbuf[0] * 16 + _tempbuf[1];
              }
              #endif
 157          
 158          
 159          
 160          /*------------------------------------------------
 161          返回 iterator-end-idx，相当于len
 162          ------------------------------------------------*/
 163          #if 0
              unsigned int bs_decode( unsigned char *p_src_dest )
              {
                      unsigned int i_write = 0;
                      unsigned int i_read;
                       
                      for( i_read = 0; p_src_dest[i_read]; i_read++ )
                      {
                              if( p_src_dest[i_read] == '%' )
                              {
                                      i_read++;
              
                                      p_src_dest[i_write] = bs_A_9( p_src_dest+i_read );      // using bs_A_9
              
                                      i_read++;
                                      i_write++;
                              }
C51 COMPILER V9.00   A_STRFUNC                                                             12/15/2017 18:39:34 PAGE 4   

                              else
                              {
                                      if( i_write != i_read) 
                                              p_src_dest[i_write] = p_src_dest[i_read];
                                      i_write++;
                              }
                      }
                      
                      p_src_dest[i_write] = 0;
              
                      return i_write;
              }
              #endif
 193          
 194          
 195          
 196          
 197          
 198          #if 0
              U8 *pick_strarr2( U8 idx, U8 *s0, U8 *s1 )
              {
                      if( idx == 0 ) return s0;
                      return s1;
              }
              #endif
 205          
 206          
 207          
 208          
 209          
 210          /*------------------------------------------------
 211            7段数码管，字模 
 212          ------------------------------------------------*/
 213          
 214          #if 0
              
                  static unsigned code LEDtable[] =
                      //共阴 
                      // 0     1      2     3     4     5     6    7      8     9     10   11     12    13    14   15     16   
             - 17    18    19   20    21     22    23
                      //"0    "1"     2"    3"   4"     5   "6"    "7    "8    9      A    B      C     D     E    F      H    
             - L     n     u     P     o"   "-"  熄灭
                      { 0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0x71, 0x76, 0
             -x38, 0x37, 0x3E, 0x73, 0x5C, 0x40, 0x00 };
                      //共阳 
                      //..0.....1....2......3.....4.....5.....6......7....8.....9.....A ....b.....C.....d..... E ....F... - ...
             -.灭...............
                      //{ 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90, 0x88, 0x83, 0xc6, 0xa1, 0x86, 0x8e, 0xbf,
             - 0xff };        
                  static unsigned code LEDtable1[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 
             -'D', 'E', 'F', 'H', 'L', 'N', 'U', 'P', 'O', '-', \0 };
                  static unsigned code LEDtable2[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 
             -'d', 'e', 'f', 'h', 'l', 'n', 'u', 'p', 'o', '-', \0 };
              
              unsigned char GetLED( unsigned char s )
              {
                      unsigned char c1;
                      unsigned char j;
              
                      if( s <= 9 )
                      {
                              //直接找数字型 
C51 COMPILER V9.00   A_STRFUNC                                                             12/15/2017 18:39:34 PAGE 5   

                              c1 = LEDtable[s];
                      }
                      else
                      {
                              for( j = 0; LEDtable1[j]; j++ )
                              {
                                      if( s == LEDtable1[j] || s == LEDtable2[j] ) break;
                              }
                              c1 = LEDtable[j];
                      }
                      
                      //return c1;    //共阴 
                      return ~c1;      //共阳
              }
              
              #endif
 251          
 252          
 253           
 254          
 255          
 256          
 257          
 258          #if 0
              void mk_busycode( unsigned char src, unsigned char *pDest )
              {
                      unsigned char mask;
                      unsigned char i;
              
                      //pDest[0] = 0xff;
                      //pDest[1] = 0xff; 不怕垃圾值干扰       
              
                      mask = 0x80;
                      for( i = 0; i < 8; i++ )
                      {
                              if( src & mask ) // 1 -> 01
                              {
                                      pDest[i/4] <<= 1;
                                      pDest[i/4] &= 0xfe;
              
                                      pDest[i/4] <<= 1;
                                      pDest[i/4] |= 1;
                              }
                              else
                              {
                                      pDest[i/4] <<= 1;
                                      pDest[i/4] |= 1;
              
                                      pDest[i/4] <<= 1;
                                      pDest[i/4] &= 0xfe;
                              }
                              mask >>= 1;
                      }
              }
              #endif
 290          
 291          
 292          
 293          
 294          #if 0
              unsigned char chk_busycode( unsigned char *p )
              {
C51 COMPILER V9.00   A_STRFUNC                                                             12/15/2017 18:39:34 PAGE 6   

                      unsigned char i;
                      unsigned char c;
              
                      //c = 0xff; 不怕垃圾值干扰      
              
                      for( i = 0; i < 8; i++ )
                      {
                              if( p[i/4] & 0x80 )
                              {
                                      c <<= 1;
                                      c &= 0xfe;
                              }
                              else
                              {
                                      c <<= 1;
                                      c |= 1;
                              }
                               
                              p[i/4] <<= 1;
                              p[i/4] <<= 1;
                      }
                      return c;
              }
              #endif
 321          
 322          
 323          
 324          
 325          
 326          
 327          #if 0
              
              //signed char mycompare( unsigned char *a1, unsigned char *a2, int datablocklen )
              //{
              //      if( *a1 > *a2 ) return 1;
              //      if( *a1 == *a2 ) return 0;
              //      /*if( *a1 < *a2 )*/ return -1;
              //}
              //signed char mycompare( unsigned char *a1, unsigned char *a2, int datablocklen )
              //{
              //      if( *(int*)a1 > *(int*)a2 ) return 1;
              //      if( *(int*)a1 == *(int*)a2 ) return 0;
              //      /*if( *a1 < *a2 )*/ return -1;
              //}
              signed char mycompare( unsigned char *a1, unsigned char *a2 ) reentrant
              {
                      if( *(unsigned long*)a1 > *(unsigned long*)a2 ) return 1;
                      if( *(unsigned long*)a1 == *(unsigned long*)a2 ) return 0;
                      /*if( *a1 < *a2 )*/ return -1;
              }
              
              #endif
 349          
 350          
 351          
 352          #if 0
              void a_sortf( unsigned char *x, int datablocknum, int datablocklen, pf_compare_t pf_comp )
              {
                      int a,b,c;
              
                      for( a = 0; a < datablocknum - 1; a ++ ) 
                      {
C51 COMPILER V9.00   A_STRFUNC                                                             12/15/2017 18:39:34 PAGE 7   

                              for( b = a + 1; b < datablocknum; b++ )   
                              {
                                      //if( (*pf_comp)( x+a*datablocklen, x+b*datablocklen, datablocklen ) > 0 )       
                                      if( (*pf_comp)( x+a*datablocklen, x+b*datablocklen ) > 0 )       
                                      {
                                              for( c = 0; c < datablocklen; c++ )
                                              {
                                                      *(x+a*datablocklen + c) ^=      *(x+b*datablocklen + c);
                                                      *(x+b*datablocklen + c) ^=      *(x+a*datablocklen + c);
                                                      *(x+a*datablocklen + c) ^=      *(x+b*datablocklen + c);
                                              }
                                      } 
                              }
                      }
              }
              #endif
 375          
 376          //用法：
 377          //void test_sort()
 378          //{
 379          //      int x[4]={ 5990, 9991, 772, 7723 };
 380          //
 381          //      a_sortf( (unsigned char*)x, 4, 4, mycompare );
 382          
 383          //////a_sortf( (unsigned char*)(&()), 4, 4, mycompare );
 384          //
 385          //      for( int i = 0; i < 4; i++ )
 386          //      {
 387          //              printf( "%d %d\n", i, x[i] );
 388          //      }
 389          //}
 390          
 391          
 392          
 393          // 直接实现：
 394          //void a_sortf( unsigned char *x, int datablocknum, int datablocklen )
 395          //{
 396          //      int a,b,c;
 397          //      unsigned char *a1;
 398          //      unsigned char *a2;
 399          //
 400          //      for( a = 0; a < datablocknum - 1; a ++ ) 
 401          //      {
 402          //              for( b = a + 1; b < datablocknum; b++ )   
 403          //              {
 404          //                      a1 = x+a*datablocklen;
 405          //                      a2 = x+b*datablocklen;
 406          //                      if( *(unsigned long*)a1 > *(unsigned long*)a2 )       
 407          //                      {
 408          //                              for( c = 0; c < datablocklen; c++ )
 409          //                              {
 410          //                                      *(x+a*datablocklen + c) ^=      *(x+b*datablocklen + c);
 411          //                                      *(x+b*datablocklen + c) ^=      *(x+a*datablocklen + c);
 412          //                                      *(x+a*datablocklen + c) ^=      *(x+b*datablocklen + c);
 413          //                              }
 414          //                      } 
 415          //              }
 416          //      }
 417          //}
 418          
 419          
 420          
C51 COMPILER V9.00   A_STRFUNC                                                             12/15/2017 18:39:34 PAGE 8   

 421          
 422          
 423          
 424          
 425          
 426          /*------------------------------------------------
 427           一种校验 
 428          ------------------------------------------------*/
 429                  
 430          /////////==============版本1    传统做法
 431          
 432          #if 0
              void mk_chksumU8( unsigned char * sz1, unsigned int iLen )// 对缓冲区最后一个字节写校验数据     
              {
                      unsigned char c1 = 0;
                      unsigned int j;
                      
                      //求和 进c1
                      for( j = 0 ; j < iLen - 1; j ++ )
                              c1 += sz1[j];  
              
                      sz1[iLen-1] = c1;
              }
              #endif
 445          
 446          
 447          #if 0
              unsigned char chk_chksumU8( unsigned char * sz1, unsigned int iLen ) //检查缓冲区最后一字节是否对。     
              {
                      unsigned char c1 = 0;
                      unsigned int j;
                      
                      //求和 进c1
                      for( j = 0 ; j < iLen - 1; j ++ )
                              c1 += sz1[j];  
              
                      if( sz1[iLen-1] == c1 ) 
                              return 1;
                      else
                              return 0;
              }
              #endif
 463          
 464          
 465          
 466          
 467          
 468          //////////=======版本2  有位置信息
 469          //2016-08-12如果用c1 ^= ( sz1[j] + (unsigned char)j );  貌似不好用,算出来值太规整       
 470          
 471          #if 0
              void mk_chk2sumU8( unsigned char * sz1, unsigned int iLen )
              {
                      unsigned char c1 = 0;
                      unsigned int j;
                      
                      //求和 进c1
                      for( j = 0 ; j < iLen - 1; j ++ )
                              c1 += ( sz1[j] ^ (unsigned char)j );  
              
                      if( c1 == 0 || c1 == 255 ) c1 = 1;
              
C51 COMPILER V9.00   A_STRFUNC                                                             12/15/2017 18:39:34 PAGE 9   

                      sz1[iLen-1] = c1;
              }
              #endif
 486          
 487          
 488          
 489          #if 0
              unsigned char chk_chk2sumU8( unsigned char * sz1, unsigned int iLen )
              {
                      unsigned char c1 = 0;
                      unsigned int j;
                      
                      //求和 进c1
                      for( j = 0 ; j < iLen - 1; j ++ )
                              c1 += ( sz1[j] ^ (unsigned char)j );  
              
                      if( c1 == 0 || c1 == 255 ) c1 = 1;
              
                      if( sz1[iLen-1] == c1 ) 
                              return 1;
                      else
                              return 0;
              }
              #endif
 507          
 508          
 509          
 510          
 511          
 512          
 513          //////////=======版本3  加上长度
 514          
 515          #if 0
              void mk_chk3sumU8( unsigned char * sz1, unsigned int iLen )// 对缓冲区最后一个字节写校验数据    
              {
                      unsigned char c1 = 0;
                      unsigned int j;
                      
                      //求和 进c1
                      for( j = 0 ; j < iLen - 1; j ++ )
                              c1 += sz1[j];  
              
                      sz1[iLen-1] = c1 + iLen;
              }
              #endif
 528          
 529          
 530          #if 0
              unsigned char chk_chk3sumU8( unsigned char * sz1, unsigned int iLen ) //检查缓冲区最后一字节是否对。    
              {
                      unsigned char c1 = 0;
                      unsigned int j;
                      
                      //求和 进c1
                      for( j = 0 ; j < iLen - 1; j ++ )
                              c1 += sz1[j];  
              
                      if( sz1[iLen-1] == ( c1+iLen ) ) 
                              return 1;
                      else
                              return 0;
              }
C51 COMPILER V9.00   A_STRFUNC                                                             12/15/2017 18:39:34 PAGE 10  

              #endif
 546          
 547          
 548          
 549          
 550          
 551          
 552          //////
 553          //////=======版本4      多字节校验码
 554          
 555          #if 0
                      void mk_chk2sumU8_internal_for_chk4( unsigned char * sz1, unsigned int iLen )
                      {
                              unsigned char c1 = 0;
                              unsigned int j;
                              
                              //求和 进c1
                              for( j = 0 ; j < iLen - 1; j ++ )
                                      c1 += ( sz1[j] ^ (unsigned char)j );  
              
                              if( c1 == 0 || c1 == 255 ) c1 = 1;
              
                              sz1[iLen-1] = c1;
                      }
              
              
              void mk_chk4sumU8( unsigned char * sz1, unsigned int iBufLen, unsigned char iChkLen )
              {
                      unsigned char chklen;
                      
                      for( chklen = 1; chklen <= iChkLen; chklen++ )
                      {
                              mk_chk2sumU8_internal_for_chk4( sz1, iBufLen - iChkLen + chklen );
                      }
              }
              #endif
 581          
 582          
 583          
 584          #if 0
                      unsigned char chk_chk2sumU8_internal_for_chk4( unsigned char * sz1, unsigned int iLen )
                      {
                              unsigned char c1 = 0;
                              unsigned int j;
                              
                              //求和 进c1
                              for( j = 0 ; j < iLen - 1; j ++ )
                                      c1 += ( sz1[j] ^ (unsigned char)j );  
              
                              if( c1 == 0 || c1 == 255 ) c1 = 1;
              
                              if( sz1[iLen-1] == c1 ) 
                                      return 1;
                              else
                                      return 0;
                      }
              
              unsigned char chk_chk4sumU8( unsigned char * sz1, unsigned int iBufLen, unsigned char iChkLen )
              {
                      unsigned char chklen;
                      
                      for( chklen = 1; chklen <= iChkLen; chklen++ )
C51 COMPILER V9.00   A_STRFUNC                                                             12/15/2017 18:39:34 PAGE 11  

                      {
                              if( !chk_chk2sumU8_internal_for_chk4( sz1, iBufLen - iChkLen + chklen ) ) return 0;
                      }
                       
                      return 1;
              }
              #endif
 614          
 615          
 616          
 617          
 618          
 619          
 620          //////============
 621          //////=======版本5      多字节，且兼容传统加法BCC
 622          //////
 623          
 624          #if 0
                      void mk_chksumU8_internal_for_ck5( unsigned char * sz1, unsigned int iLen ) 
                      {
                              unsigned char c1 = 0;
                              unsigned int j;
                              
                              //求和 进c1
                              for( j = 0 ; j < iLen - 1; j ++ )
                                      c1 += sz1[j];  
              
                              sz1[iLen-1] = c1;
                      }
              
              
              void mk_chk5sumU8( unsigned char * sz1, unsigned int iBufLen, unsigned char iChkLen )
              {
                      unsigned char chklen;
                      
                      for( chklen = 1; chklen <= iChkLen; chklen++ )
                      {
                              mk_chksumU8_internal_for_ck5( sz1, iBufLen - iChkLen + chklen );
                      }
              }
              #endif
 648          
 649          
 650          
 651          
 652          #if 0
                      unsigned char chk_chksumU8_internal_for_ck5( unsigned char * sz1, unsigned int iLen )  
                      {
                              unsigned char c1 = 0;
                              unsigned int j;
                              
                              //求和 进c1
                              for( j = 0 ; j < iLen - 1; j ++ )
                                      c1 += sz1[j];  
              
                              if( sz1[iLen-1] == c1 ) 
                                      return 1;
                              else
                                      return 0;
                      }
              
              
C51 COMPILER V9.00   A_STRFUNC                                                             12/15/2017 18:39:34 PAGE 12  

              unsigned char chk_chk5sumU8( unsigned char * sz1, unsigned int iBufLen, unsigned char iChkLen )
              {
                      unsigned char chklen;
                      
                      for( chklen = 1; chklen <= iChkLen; chklen++ )
                      {
                              if( !chk_chksumU8_internal_for_ck5( sz1, iBufLen - iChkLen + chklen ) ) return 0;
                      }
                       
                      return 1;
              }
              #endif
 681          
 682          
 683          
 684          
 685          
 686          
 687          
 688          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
